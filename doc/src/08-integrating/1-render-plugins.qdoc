/****************************************************************************
**
** Copyright (C) 1993-2009 NVIDIA Corporation.
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of Qt 3D Studio.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\title Render Plugins
\page integrating-render-plugins.html
\ingroup qt3dstudio-integrating

Qt 3D Studio provides a mechanism for
compositing an external OpenGL ES application plugin as a texture at
runtime. This document describes how this is done.

\section1 Requirements

In general, the initialization and rendering portions of the plugin must
be modified to be driven by the runtime.

First, the plugin application needs to be converted into a dynamic
library. The extension of the dynamic library should be \c{.dll}
for Windows, and \c{.so} for Linux. (See further instructions in
the \e{Usage} section below.)

Second, the functions in the header file (\c{UICPluginDLL.h}) need
to be implemented by the plugin.

The following list is a description of these functions and what they
need to do. The order the functions are listed here also represents the
expected calling sequence of these functions.

\section2 \c{long GetPluginType( )}

This must return \c{EDLLTYPE\_RENDERABLE\_PLUGIN}.

\section2 \c{void Initialize( const char* inArgs )}

This function should do any initialization (data setup, geometry and
texture uploads, etc.) required by the plugin. It will be called when
the dynamic library is loaded during runtime startup.

\section2 \c{void Uninitialize( )}

This function should do any uninitialization (free memory, close files,
etc) required by the plugin. It will be called when the viewer is
exited.

\section2 \c{void GetDesiredTextureSize( long* outWidth, out* outHeight, ETEXTUREFORMAT *outTextureFormat )}

The plugin should set \c{outWidth} and \c{outHeight} to its
desired rendering size, and set the texture format to one of:

\list
\li
  \c{ETEXTUREFORMAT\_ANY}
\li
  \c{ETEXTUREFORMAT\_RGB565}
\li
  \c{ETEXTUREFORMAT\_BGR565}
\li
  \c{ETEXTUREFORMAT\_RGB888}
\li
  \c{ETEXTUREFORMAT\_BGR888}
\endlist
\section2 \c{void SetAllocatedRenderInfo( long inFBO, long inRBO, long inTex, ETEXTUREFORMAT inTextureFormat )}

The runtime uses this function to send the framebuffer, renderbuffer and
texture handles used for rendering. The plugin should store these and
activate them when rendering. Note that the data within these handles
are shared resources, and may be modified between calls to
\c{Render( )}.

\section2 \c{[Optional] void SetEGLInfo( void* inEGLdisplay, void* inEGLCurrentContext, void* inEGLSurface, void* inEGLConfig )}

The runtime uses this function to send information about the current EGL
environment. The plugin should store these parameters and use them in
\c{EGLCreateContext} and \c{EGLMakeCurrent}.

Implementing this function is necessary when using
\c{EGLMakeCurrent} for state management.

\section2 \c{void Render( long inHostWidth, long inHostHeight, long inDrawTime )}

The runtime calls this whenever it requires a frame from the plugin. The
plugin should render its results into the texture handle provided by
\c{SetAllocatedRenderInfo}. The parameters, \c{inHostWidth}
and \c{inHostHeight} represent the current dimensions of the host
rectangle, and may be useful for clipping/scaling optimizations. The
parameter \c{inDrawTime} represents the current frame time in
milliseconds.

\section1 State Management

The plugin should manage its OpenGLES state properly so that it does not
affect the runtime. There are two approaches that can be adopted.

\list
\li
  In the first approach, the plugin creates its own EGLContext to
  contain its state. It should switch to this context during
  \c{Render()} and switch back to the runtime's context before
  returning from \c{Render()}.
\endlist
Switching contexts is slow but might be favorable if the plugin spends a
lot of time rendering or doing complex state changes.

\list
\li
  The second approach is to share the OpenGL state between the runtime
  and the plugin. The plugin is responsible for restoring state changes
  it makes during \c{Render( )}. However, the shader program,
  framebuffer and viewport settings will be restored by the runtime
  automatically, as these are most likely to have changed. This approach
  is faster than switching contexts and is probably suitable for simpler
  applications that do not make many state changes or when maximum speed
  is desired.
\endlist
\section1 Usage

The procedure for using plugins is very similar to that used for Sub
Presentations.

After converting the plugin into a dynamic library, the
\l{file-formats-uia.html}{\c{.uia} file} should be
modified to specify the dynamic library as a
\c{<renderplugin>} asset. The
\c{src="..."} attribute should point to the dynamic library.
For example:

\badcode
<application xmlns="http://nvidia.com/uicomposer">
  <assets>
    ...
    <renderplugin id="plugin:mapviewer" src="scripts/mylib.so" args="whee"  />
  </assets>
  ...
</<application>
\endcode

Then, in Qt 3D Studio application for the presentation to display this
plugin, either:

\list
\li
  choose a Layer to display the plugin by setting the Sub-Presentation
  property to the string \c{plugin:mapviewer} (the \c{id}
  attribute of the asset), or
\li
  choose an image to display the composited texture by setting the
  Sub-Presentation property on the image similarly.
\endlist

Finally, ensure that the dynamic library and the support files (if any)
that are required are copied to your project folder.
*/
