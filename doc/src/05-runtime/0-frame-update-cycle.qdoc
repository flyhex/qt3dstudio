/****************************************************************************
**
** Copyright (C) 1993-2009 NVIDIA Corporation.
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of Qt 3D Studio.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\title Runtime: Frame Update Cycle
\page runtime-frame-update-cycle.html
\ingroup qt3dstudio-runtime

Qt 3D Studio presents a
simple, elegant interface for creating interactive 3D content. Concepts
like Slides, Components, Actions, Events, Behaviors, Eye-Toggles, and
the Animation Timeline are highly intuitive and represent a very
accessible interface for controlling what is a necessarily complex
real-time runtime system for managing interactive 3D content.

The Qt 3D Studio Runtime operates with a deterministic set of
rules that bring the content created with Qt 3D Studio to life.
This document outlines what happens in a
\b{single frame} in terms of the runtime to make this happen.

The calculations and order of operations involved in each frame are
fairly complex; in order to explain things more clearly it is helpful to
think of each frame being made up of several logical stages. Here is the
full overview of the different conceptual stages.

\section1 Input

A frame is kicked off by calling \c{CRuntime::UpdatePresentations};
this immediately results in a call to
\c{CInputEngine::GetInputFrame}. A subclass of
\c{CInputEngine} will take this opportunity to poll the state of
the various input devices and fire events indicating user interaction.
The base class version of \c{CInputEngine} implements
\c{HandleInputEvent} which can be used to do this simply.

\section1 Stage 0: Time Distribution

This stage is opaque and will be relatively invisible to you. Before any
real calculations for this frame can begin, various time related
activities need to be complete. For instance, each presentation itself
can be playing or paused. This stage manages this and other time related
things.

\section1 Stage 1: Process Events

The next result of calling \c{CRuntime::UpdatePresentations} is the
processing of events.

The Runtime maintains a first-in/first-out queue of events that are
waiting to be processed. When event processing starts this queue will
contain events that were fired during the input stage as described above
as well as any events that were fired on the previous frame after event
processing was completed.

The critical rule of event processing is that all events will be
processed before this stage ends and the next stage begins. This
includes events that are fired during event processing. This contract
allows the Runtime to support chained events, meaning that any event
fired as a result of processing another event will be handled in the
same frame. This contract helps to ensure consistent presentation state.

It is interesting to note that because slide changes can only be
affected as a result of processing events; all slide changes will take
place during this stage.

\section1 Stage 2: Active Scan

Once all the events for this frame have been processed, and the event
queue is empty, a full scan of the graph of elements is performed to
find out which elements will be active this frame. The processing of
events will result in slide changes and changes to properties which will
affect the appearance of the presentation. During this stage, a
definitive list of which elements are active is created and this list
will be used by subsequent stages to efficiently do their jobs.

It is interesting to note that because this `active list' is created
here, and is used by all further stages, changes to the active state of
any elements made after this stage will not take effect until the next
frame (when the list is calculated again). By clearly drawing this line
at this stage we can avoid many of the \"doing various things before (or
after) you exist\" paradoxes inherent in a complex frame rhythm.

\section1 Stage 3: Animation

After the list of active elements for this frame has been decided, the
Runtime calculates new values for any animated properties on active
elements, and applies the new values.

\target script-callbacks
\section1 Stage 4: Script Callbacks

The final act of \c{CRuntime::UpdatePresentations} is to call the
special active dependent script callbacks. By comparing this frame's
active list with the active list from the previous frame the Runtime can
determine which elements are becoming active or inactive. The Runtime
uses this information to initiate the following script callbacks:

\section2 \c{onDeactivate}

First, any behaviors which were active last frame that are not active
this frame will have their \c{onDeactivate} handler called. If
multiple behaviors match this the callbacks for parent elements will
occur before their children/descendants.

\section2 \c{onInitialize}

On the very first frame a behavior is active it will have its
\c{onInitialize} handler called. If multiple behaviors match this
the callbacks for parent elements will occur before their
children/descendants. Note that each behavior will only have its
\c{onInitialize} handler called once, even if it is deactivated and
later reactivated.

\section2 \c{onActivate}

Next, any behaviors which were not active last frame that are active
this frame will have their \c{onActivate} handlers called. If
multiple behaviors match this the callbacks for parent elements will
occur before their children/descendants.

\section2 \c{onUpdate}

Finally, any behaviors that are active this frame will have their
\c{onUpdate} handler called. If multiple behaviors match this the
callbacks for parent elements will occur before their
children/descendants.

\section1 Stage 5: Scene Graph Update

The next call you will make is \c{CRuntime::UpdateScenes}. All the
activity before this has performed the calculations in the Runtime to
ensure the presentation is in a newly updated state for this frame.
Calling \c{UpdateScenes} will first result in any changed
attributes being communicated through the scene graph to your
application through calls to \c{CRenderEngine::SetAttributes}.
Then, a recursive update is done on the assets in the scene graph to
calculate updated global matrices and hierarchical opacity values.

\section1 Stage 6: Render

Finally you will call \c{CRuntime::Render}. This stage consumes all
the calculated values produced by the previous stages and translates
them into calls on your engine specific subclass of
\c{CRenderEngine}. This includes calls like \c{SetTransform}
which will communicate the updated global matrices to you and
\c{DrawItem} which will indicate that you need to draw a specific
item in the scene.
*/
